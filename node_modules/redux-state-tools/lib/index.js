"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var mapObject = function mapObject(obj, fn) {
  var result = {};
  Object.keys(obj).forEach(function (key) {
    result[key] = fn(obj[key]);
  });
  return result;
};

var prefixedReducer = function prefixedReducer(prefix, reducer) {
  var exceptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
  return function (state, action) {
    if (state === undefined) return reducer(state, action);
    if (exceptions && exceptions.includes(action.type)) return reducer(state, action);

    var type = action.type,
        rest = _objectWithoutProperties(action, ["type"]);

    if (type.startsWith(prefix + "_")) {
      return reducer(state, _extends({}, rest, {
        type: type.slice(prefix.length + 1)
      }));
    }
    return state;
  };
};

exports.prefixedReducer = prefixedReducer;
var prefixedTypes = exports.prefixedTypes = function prefixedTypes(prefix, actions) {
  var convert = function convert(type) {
    return prefix + "_" + type;
  };
  return mapObject(actions, convert);
};

var prefixedActions = exports.prefixedActions = function prefixedActions(prefix, actions) {
  var convertToActionCreator = function convertToActionCreator(arg) {
    if (typeof arg === "string") {
      return prefix + "_" + arg;
    } else {
      var _arg = _toArray(arg),
          type = _arg[0],
          args = _arg.slice(1);

      return [prefix + "_" + type].concat(_toConsumableArray(args));
    }
  };
  return mapObject(actions, convertToActionCreator);
};

var makeActionCreator = function makeActionCreator(arg) {
  var type = void 0;
  var params = [];
  if (Array.isArray(arg)) {
    type = arg[0];
    params = arg.slice(1);
  } else {
    type = arg;
  }
  params.forEach(function (param) {
    if (typeof param !== "string") throw new Error("the arguments to actionCreator must all be strings");
  });
  return function (args) {
    var result = { type: type };
    params.forEach(function (param) {
      if (param[0] === '!') {
        result[param] = true;
      } else {
        result[param] = args[param];
      }
    });
    return result;
  };
};

var makeActionCreators = exports.makeActionCreators = function makeActionCreators(actions) {
  return mapObject(actions, makeActionCreator);
};

var prefixedActionCreators = exports.prefixedActionCreators = function prefixedActionCreators(prefix, actions) {
  return makeActionCreators(prefixedActions(prefix, actions));
};

var prefixedSelectors = exports.prefixedSelectors = function prefixedSelectors(prefix, selectors) {
  return mapObject(selectors, function (selector) {
    return function (state) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return selector.apply(undefined, [state[prefix]].concat(args));
    };
  });
};

var makeMiddleware = exports.makeMiddleware = function makeMiddleware(key, func) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (actionIn) {
        if (actionIn["!" + key]) {
          var action = _extends({}, actionIn);
          delete action["!" + key];
          return func(action, { dispatch: dispatch, getState: getState, next: next });
        } else {
          return next(actionIn);
        }
      };
    };
  };
};

var appendItems = function appendItems(arg, items) {
  if (Array.isArray(arg)) return [].concat(_toConsumableArray(arg), _toConsumableArray(items));else return [arg].concat(_toConsumableArray(items));
};

var append = function append(arg, item) {
  if (Array.isArray(arg)) return [].concat(_toConsumableArray(arg), [item]);else return [arg, item];
};

var withMiddleware = exports.withMiddleware = function withMiddleware(key, actions) {
  return mapObject(actions, function (arg) {
    return append(arg, "!" + key);
  });
};